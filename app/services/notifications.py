
import httpx
import resend

from app.config import settings


class NotificationError(Exception):
    """Raised when a notification fails to send."""
    pass


def format_summary_for_text(summary_data: dict, filename: str) -> str:
    """
    Format the summary data as plain text for email/Slack.
    """
    lines = [f"# Meeting Notes: {filename}\n"]

    # summary
    if summary_data.get("summary"):
        lines.append("## Summary")
        for item in summary_data["summary"]:
            lines.append(f"- {item}")
        lines.append("")

    # action items
    if summary_data.get("action_items"):
        lines.append("## Action Items")
        for item in summary_data["action_items"]:
            owner = f" ({item['owner']})" if item.get("owner") else ""
            lines.append(f"- {item['task']}{owner}")
        lines.append("")

    # key decisions
    if summary_data.get("key_decisions"):
        lines.append("## Key Decisions")
        for item in summary_data["key_decisions"]:
            lines.append(f"- {item}")
        lines.append("")

    # follow-up questions
    if summary_data.get("follow_up_questions"):
        lines.append("## Follow-up Questions")
        for item in summary_data["follow_up_questions"]:
            lines.append(f"- {item}")

    return "\n".join(lines)


def format_summary_for_html(summary_data: dict, filename: str) -> str:
    """
    Format the summary data as HTML for email.
    """
    html = f"""
    <html>
    <head>
        <style>
            body {{ font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; line-height: 1.6; color: #333; max-width: 600px; margin: 0 auto; padding: 20px; }}
            h1 {{ color: #1a1a1a; border-bottom: 2px solid #2563eb; padding-bottom: 10px; }}
            h2 {{ color: #374151; margin-top: 24px; }}
            ul {{ padding-left: 20px; }}
            li {{ margin-bottom: 8px; }}
            .owner {{ background: #2563eb; color: white; padding: 2px 8px; border-radius: 4px; font-size: 12px; }}
            .footer {{ margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; font-size: 12px; }}
        </style>
    </head>
    <body>
        <h1>Meeting Notes: {filename}</h1>
    """

    # summary
    if summary_data.get("summary"):
        html += "<h2>Summary</h2><ul>"
        for item in summary_data["summary"]:
            html += f"<li>{item}</li>"
        html += "</ul>"

    # action items
    if summary_data.get("action_items"):
        html += "<h2>Action Items</h2><ul>"
        for item in summary_data["action_items"]:
            owner = f' <span class="owner">{item["owner"]}</span>' if item.get("owner") else ""
            html += f"<li>{item['task']}{owner}</li>"
        html += "</ul>"

    # key decisions
    if summary_data.get("key_decisions"):
        html += "<h2>Key Decisions</h2><ul>"
        for item in summary_data["key_decisions"]:
            html += f"<li>{item}</li>"
        html += "</ul>"

    # follow-up questions
    if summary_data.get("follow_up_questions"):
        html += "<h2>Follow-up Questions</h2><ul>"
        for item in summary_data["follow_up_questions"]:
            html += f"<li>{item}</li>"
        html += "</ul>"

    html += """
        <div class="footer">
            Generated by Meeting Notes System
        </div>
    </body>
    </html>
    """

    return html


async def send_email(
    to_email: str,
    summary_data: dict,
    filename: str,
    subject: str | None = None
) -> dict:
    """
    Send meeting notes via email using Resend.
    Returns the response from Resend API.
    """
    if not settings.resend_api_key:
        raise NotificationError("Email not configured. Set RESEND_API_KEY in .env")

    resend.api_key = settings.resend_api_key

    if not subject:
        subject = f"Meeting Notes: {filename}"

    html_content = format_summary_for_html(summary_data, filename)
    text_content = format_summary_for_text(summary_data, filename)

    try:
        response = resend.Emails.send({
            "from": settings.email_from,
            "to": [to_email],
            "subject": subject,
            "html": html_content,
            "text": text_content,
        })
        return {"success": True, "id": response.get("id")}

    except Exception as e:
        raise NotificationError(f"Failed to send email: {str(e)}")


async def send_slack(
    summary_data: dict,
    filename: str,
    webhook_url: str | None = None
) -> dict:
    """
    Send meeting notes to Slack via webhook.
    Can use default webhook from settings or a custom one.
    """
    url = webhook_url or settings.slack_webhook_url

    if not url:
        raise NotificationError("Slack not configured. Set SLACK_WEBHOOK_URL in .env")

    # format for Slack using blocks for better formatting
    blocks = [
        {
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": f"Meeting Notes: {filename}",
                "emoji": True
            }
        }
    ]

    # summary section
    if summary_data.get("summary"):
        summary_text = "\n".join([f"• {item}" for item in summary_data["summary"]])
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*Summary*\n{summary_text}"
            }
        })

    # action items
    if summary_data.get("action_items"):
        actions_text = "\n".join([
            f"• {item['task']}" + (f" `{item['owner']}`" if item.get("owner") else "")
            for item in summary_data["action_items"]
        ])
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*Action Items*\n{actions_text}"
            }
        })

    # key decisions
    if summary_data.get("key_decisions"):
        decisions_text = "\n".join([f"• {item}" for item in summary_data["key_decisions"]])
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*Key Decisions*\n{decisions_text}"
            }
        })

    # follow-up questions
    if summary_data.get("follow_up_questions"):
        questions_text = "\n".join([f"• {item}" for item in summary_data["follow_up_questions"]])
        blocks.append({
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*Follow-up Questions*\n{questions_text}"
            }
        })

    # footer
    blocks.append({
        "type": "context",
        "elements": [
            {
                "type": "mrkdwn",
                "text": "Generated by Meeting Notes System"
            }
        ]
    })

    payload = {"blocks": blocks}

    try:
        async with httpx.AsyncClient() as client:
            response = await client.post(url, json=payload)
            response.raise_for_status()
            return {"success": True}

    except httpx.HTTPError as e:
        raise NotificationError(f"Failed to send to Slack: {str(e)}")
